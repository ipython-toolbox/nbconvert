#!/usr/local/bin/python3

import os
import sys
import inspect

from argparse import ArgumentParser as ArgParser


class FSM(object):
    state = None

    def __init__(self):
        self.state = self.WAIT
        self.frame = ''

    # internal state
    (WAIT, HASHBANG, DOCSTRING, CLASSDEF, FUNCDEF, COMMENT, CODE) = [
        "WAIT", "HASH", "DOCSTRING", "CLASSDEF", "FUNCDEF", "COMMENT", "CODE"]

    def input(self, line):
        debug(6, "input: line='%s'" % line)

        stripline = line.strip()

        if self.state == SELF.WAIT:
            pass
        elif self.state == self.FUNCDEF:
            if stripline == "":
                self.state == self.CODE

        if line[0:2] == '#!':
            self.state = self.HASHBANG
        elif line[0:3] ==  "'''":
            self.state = self.DOCSTRING
        elif line[0:1] == '#':
            self.state = self.COMMENT
        elif line[0:4] == 'def ':
            self.state = self.FUNCDEF
        elif line[0:5] == 'class ':
            self.state = self.CLASSDEF
        else:
            state = self.CODE

        return (self.state, line)
debuglevel = 0


def debug(level, line):
    '''
    Write debug message to output
    '''

    call = inspect.stack()[1][3]
    this = inspect.stack()[0][3]

    if level <= debuglevel:
        print("DBG: %-10s %s" % (call, line))


def Parse(filename):
    debug(4, "parse file %s" % filename)

    with open(filename, 'r') as f:
        debug(4, "parse lines")
        for line in f.read().splitlines():
            debug(6, "return line '%s'" % line)

            yield line

    debug(4, "done")

    yield None


def cell(lines, typ="code", isfirstcell=False):
    '''
    write a code cell:
    type = 'code' or 'markdown'
    '''

    indent = '\t'

    if isfirstcell:
        content = ""
    else:
        content = indent + indent + ",\n"

    debug(4, "CELL: is first cell=%r, typ=%r" % (isfirstcell, typ))

    content += indent + indent + "{" + \
        indent + "\"cell_type\": \"" + typ + "\", "

    if typ == "code":
        content += "\"execution_count\": 2, \"metadata\": { \"collapsed\": false }, \"outputs\": []"
    else:
        content += "\"metadata\": {}"

    content += ", \n"
    content += indent + indent + indent + "\"source\": [\n"

    lastline = len(lines) - 1

    for thisline, line in enumerate(lines):
        content += indent + indent + indent + \
            indent + "\"" + str(line) + "\\n\""

        if thisline == lastline:
            pass
        else:
            content += ","

        content += "\n"

    content += indent + indent + indent + "]\n"
    content += indent + indent + "}\n"

    # debug(4, "CELL: line=%s" % content)

    return content


def NB_START():
    return  '{' \
            '\t"cells": ['


def NB_END():
    return  '\t],' \
            '\t"metadata": {' \
            '\t\t"anaconda-cloud": {},' \
            '\t\t"kernelspec": { "display_name": "python3", "language": "python", "name": "python3" },' \
            '\t\t"language_info": { "codemirror_mode": { "name": "ipython", "version": 3 },' \
            '\t\t"file_extension": ".py",' \
            '\t\t"mimetype": "text/x-python",' \
            '\t\t"name": "python",' \
            '\t\t"nbconvert_exporter": "python",' \
            '\t\t"pygments_lexer": "ipython3",' \
            '\t\t"version": "3.4.2"' \
            '\t}' \
            '\t},' \
            '\t"nbformat": 4, "nbformat_minor": 0}'


def parse_arguments():
    parser = ArgParser()

    parser.add_argument('--input',  action='store')
    parser.add_argument('--output', action='store')
    parser.add_argument('--debug',  action='store', type=int, default=0)

    parser.add_argument('--dir',    action='store', type=str, default=".")

    parser.add_argument('--version', action='store_true',
                        help='Show the version number and exit')

    options = parser.parse_args()

    if isinstance(options, tuple):
        args = options[0]
    else:
        args = options
    del options

    # Print the version and exit
    if args.version:
        version()
        sys.exit(0)

        #
    global debuglevel
    debuglevel = args.debug

    return args


def main():
    '''
    Main
    '''

    args = parse_arguments()

    files = []
    if args.input == None:
        for dpath, _, filenames in os.walk(args.dir):
            for fname in filenames:
                if fname[-3:] == '.py':
                    files.append(dpath + '/' + fname)
    else:
        files = [args.input]

    parser = Parse(files[0])
    line = next(parser)

    fsm = FSM()

    while True:
        line = next(parser)
        debug(4, "line = '%s'" % line)
        if line == None:
            break

        (state, line) = fsm.input(line)

        print('%10s: %s' % (state, line))

    sys.exit(0)

    for py_path in files:
        nb_path = py_path[:-3] + '.ipynb'

        debug(4, "MAIN: convert %s to %s" % (py_path, nb_path))

        with open(py_path, 'r') as f_in, open(nb_path, 'w') as f_out:
            debug(4, "MAIN: write notebook start header")
            f_out.write(NB_START())

            remove_blank_lines = False
            ignore_line = False
            is_newcell = True
            is_firstcell = True

            lines = []

            state = ""

            for line in f_in.read().splitlines():
                ignore_line = True

                debug(4, "MAIN: isnew=%r removeblank=%r handle next line: '%s'" % (
                    is_newcell, remove_blank_lines, line))

                linetyp = line[0:3]

                if linetyp == '#!/':
                    state = "in hashbang"
                    remove_blank_lines = True

                    debug(4, "skip hashbang")
                    continue

                if len(line) == 0 and remove_blank_lines:
                    debug(4, "skip empty line")
                    continue
                else:
                    remove_blank_lines = False

                #
                if linetyp in ['def']:
                    celltyp = "code"
                    is_newcell = True
                elif linetyp in ['###']:
                    celltyp = "markdown"
                    debug(4, "set is_newcell to %r" % is_newcell)
                    is_newcell = True
                elif linetyp in ['"""', "'''"]:
                    ignore_line = True

                    celltyp = "markdown"

                    if state == "in docstring":
                        debug(4, "set is_newcell to %r" % is_newcell)
                        is_newcell = True
                        state = ""
                    else:
                        is_newcell = False
                        state = "in docstring"
                else:
                    celltyp = "code"

                if is_newcell:

                    if len(lines) == 0:
                        debug(4, "no lines skip create cell state=%s, typ=%s" % (
                            state, celltyp))
                    else:
                        debug(4, "create cell state=%s, typ=%s" %
                              (state, celltyp))
                        content = cell(
                            lines, celltyp, isfirstcell=is_firstcell)
                        lines = []

                        debug(4, "write line %s" % line)
                        f_out.write(content)

                        is_newcell = False
                        is_firstcell = False

                if not ignore_line:
                    line = line.replace(
                        '"', '\\"').replace('\t', '   ')

                lines.append(line)

            debug(4, "MAIN: write last line")
            content = cell(lines, celltyp, isfirstcell=is_firstcell)
            f_out.write(content)

            debug(4, "MAIN: write notebook end header")
            f_out.write(NB_END())

        print("Created", nb_path)

if __name__ == '__main__':
    main()
